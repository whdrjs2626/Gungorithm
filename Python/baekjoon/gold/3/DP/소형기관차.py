"""
문제
기차는 맨 앞에 있는 기관차 1대가 손님이 탄 객차 여러 칸을 끌고 간다. 기관차가 고장나면 기차를 운행할 수 없게 되므로 최근 철도청은 기관차 고장에 대비하여 몇몇 역에 소형 기관차 3대를 배치하기로 결정하였다. 소형 기관차는 평소에 이용하는 기관차보다 훨씬 적은 수의 객차만을 끌 수 있다.

기관차가 고장났을 때 끌고 가던 객차 모두를 소형 기관차 3대가 나누어 끌 수 없기 때문에, 소형 기관차들이 어떤 객차들을 끌고 가는 것이 좋을까하는 문제를 고민하다가 다음과 같이 하기로 결정하였다.

소형 기관차가 최대로 끌 수 있는 객차의 수를 미리 정해 놓고, 그보다 많은 수의 객차를 절대로 끌게 하지 않는다. 3대의 소형 기관차가 최대로 끌 수 있는 객차의 수는 서로 같다.
소형 기관차 3대를 이용하여 최대한 많은 손님을 목적지까지 운송하도록 한다. 각 객차 마다 타고 있는 손님의 수는 미리 알고 있고, 다른 객차로 손님들이 이동하는 것은 허용하지 않는다.
각 소형 기관차는 번호가 연속적으로 이어진 객차를 끌게 한다. 객차는 기관차 바로 뒤에 있는 객차부터 시작하여 1번 부터 차례로 번호가 붙어있다.
예를 들어 기관차가 끌고 가던 객차가 7칸이고, 소형 기관차 1대가 최대로 끌 수 있는 객차 수는 2칸이라고 하자. 그리고 1번 부터 7번까지 각 객차에 타고 있는 손님의 수가 아래 표와 같다고 하자. 괄호속에 있는 숫자는 객차 번호를 나타낸다.

(1)	(2)	(3)	(4)	(5)	(6)	(7)
35	40	50	10	30	45	60
소형 기관차 3대는 각각 1-2번, 3-4번, 그리고 6-7번 객차를 끌고 가면 손님 240명을 운송할 수 있고, 이보다 많은 수의 손님을 운송할 수 없다.

기관차가 끌고 가던 객차의 수와 각 객차에 타고 있던 손님의 수, 그리고 소형 기관차가 최대로 끌수 있는 객차의 수가 주어질 때, 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 기관차가 끌고 가던 객차의 수가 입력된다. 그 수는 50,000 이하이다. 둘째 줄에는 기관차가 끌고 가던 객차에 타고 있는 손님의 수가 1번 객차부터 차례로 입력된다. 한 객차에 타고 있는 손님의 수는 100명 이하이고, 입력되는 숫자들 사이에 빈칸이 하나씩 있다. 셋째 줄에는 소형 기관차가 최대로 끌 수 있는 객차의 수가 입력된다. 그 수는 기관차가 끌고 가던 객차 수의 1/3보다 적다.

출력
한 줄에 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 출력한다.

예제 입력 1
7
35 40 50 10 30 45 60
2

예제 출력 1
240

"""

"""
문제 풀이
DP + 누적합

  N = 7
  C = 2
  35  40  50  10  30  45  60 - li
  0   35  75  125 135 165 210 270  - 누적합 sum_li
  0   1   2   3   4   5   6   7
  
  처음에 입력받은 7가지의 숫자 li을 0부터 시작해서 누적으로 더한 sum_li를 만든다.
  
  (N + 1) * 3 형태의 2차원 배열을 만든다 -> 3개인 이유
  단차는 세개로 고정되어 있기 때문
  0  0   0   0   0   0   0   0   0  -  단차 하나일때 최대값을 구하기 위한 누적합 + dp
  1  0   0   0   0   0   0   0   0  -  단차 둘일때 최대값을 구하기 위한 누적합 + dp
  2  0   0   0   0   0   0   0   0  -  단차 셋 일때 최대값을 구하기 위한 누적합 + dp
  
  sum_li를 통해 얻어낼 수 있는 점화식
  sum_li[i] - sum_li[i - 2]는 li[i] + li[i - 1] 2개의 합
  즉 125 - 35 = 40 + 50 = 90이 된다.
  
  0번째 라인부터 차례대로 점화식을 적용해본다.
  
    보기 편하게 맨 앞에 0을 제거
    35      40      50      10        30      45         60	
    0       75      90      90        90      90         105
    해당 줄은 단차 하나만 사용했을 때 (연속된 숫자 2개의 합) 최대가 되는 값을 구하는 것 -> 따라서 40부터 하나의 단차를 채울 수 있으므로 첫번째는 0이다.
    40까지 봤을땐 35 + 40 = 75가 최대
    50까지 보면 35 + 40 < 40 + 50이 크기 때문에 90으로 교체
    10까지 보면 40 + 50 > 50 + 10이기 때문에 90으로 유지가 되는 것
    
  1번쨰 라인을 보면 점화식 + 누적합이 필요하다.
    35      40      50      10        30      45         60	
    0       75      90      90        90      90         105
    0       0       0       75+50+10  135	  90+30+45   90+45+60
    해당 줄은 단차 둘을 사용했을 때 (연속된 숫자 2개의 2쌍의 합) 최대가 되는 값을 구하는 것 -> 따라서 10부터 두개의 단차를 채울 수 있으므로 4번쨰부터 시작한다.
    10을 보면 50 + 10 인데 이전 단차에 최대값은 위에서 구한 첫번쨰 줄의 dp[0][j-2]를 가져온다 -> 75 + 50 + 10 = 135
    30을 보면 10 + 30 인데 이전 단차에 최대값은 위에서 구한 90 -> 90 + 10 + 30 = 130 < 135 -> 135로 유지
    45를 보면 30 + 45 인데 이전 단차에 최대값은 위에서 구한 90 -> 90 + 30 + 45 = 165 > 135 -> 165로 변경
    ... 이렇게 2번째 라인까지 보면 마지막에 3개 단차를 썼을 때의 최대값을 구할 수 있음 
    간단한 표는 아래와 같음
    
    35      40      50      10        30      45         60	
    0       75      90      90        90      90         105
    0       0       0       75+50+10  135	  90+30+45   90+45+60
    0       0       0       0         0       210	     135+45+60

    0  0   0   75  90  90  90  90  105  -  단차 하나일때 최대값을 구하기 위한 누적합 + dp
    1  0   0   0   0   135 135 165 195  -  단차 둘일때 최대값을 구하기 위한 누적합 + dp
    2  0   0   0   0   0   0   210 240  -  단차 셋 일때 최대값을 구하기 위한 누적합 + dp
"""
import sys

N = int(sys.stdin.readline().strip())
li = list(map(int, sys.stdin.readline().strip().split(' ')))
C = int(sys.stdin.readline().strip())
sum_li = [0] * (N + 1)
dp = [[0] * (N + 1) for _ in range(3)]
for i in range(1, N + 1):
    if i == 1:
        sum_li[i] = li[i - 1]
    else:
        sum_li[i] = li[i - 1] + sum_li[i - 1]

for i in range(3):
    for j in range((i + 1) * C, N + 1):
        dp[i][j] = max(sum_li[j] - sum_li[j - C] + (dp[i - 1][j - C] if i != 0 else 0), dp[i][j - 1])

print(dp[2][N])
